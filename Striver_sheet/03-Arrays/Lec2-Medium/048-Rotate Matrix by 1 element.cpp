#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <climits>
#include <sstream>
#include <algorithm>
#include <cmath>

using namespace std;

/*
Rotate Matric by 1 element clockwise

https://www.naukri.com/code360/problems/981260?topList=striver-sde-sheet-problems&utm_source=striver&utm_medium=website&leftPanelTabValue=PROBLEM

Problem statement
Given a 2-dimensional matrix of size ‘N’ x ‘M’, rotate the elements of the matrix clockwise.

Note:
You have to rotate the image in-place

Examples:

Example1:
Input Matrix: [ [ 1, 2, 3 ]
                [ 4, 5, 6 ]
                [ 7, 8, 9 ] ]

Output Matrix: [ [ 4, 1, 2 ]
                 [ 7, 5, 3 ]
                 [ 8, 9, 6 ] ]

The output matrix is generated by rotating the elements of the input matrix in a clockwise direction. Note that every element is rotated only once.

Example2:
Sample Input 1 :
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
Sample Output 1 :
5 1 2 3
9 10 6 4
13 11 7 8
14 15 16 12

INPUT::::::
5

4 4
1  2  3  4
5  6  7  8
9  10 11 12
13 14 15 16

3 3
1 2 3
4 5 6
7 8 9

1 4
5 6 7 8

4 1
5
7
3
2

4 3
0 11 0
16 5 7
-4 17 6
11 16 18

OUTPUT::::::

5 1 2 3
9 10 6 4
13 11 7 8
14 15 16 12

4 1 2
7 5 3
8 9 6

5 6 7 8

5
7
3
2

16 0 11
-4 5 7
17 6 0
11 16 18

 */

class Solution
{
public:
    // Approach: when m!=n take min of m,n
    // Time: O(M*N)
    // Space: O(1)
    void rotateMatrix(vector<vector<int>> &arr)
    {
        int m = arr.size();    // no of rows
        int n = arr[0].size(); // no of cols

        int N = min(m, n);                  // this is needed to handle the cases where m!=n
        int noOfInnerMatrices = (int)N / 2; // Taking floor solves the issue where in the last iteration only a single element is left which should not be swapped.

        for (int k = 0; k < noOfInnerMatrices; k++)
        {

            int left = k;
            int right = m - 1 - k;
            int top = k;
            int bot = n - 1 - k;

            int prev = arr[top + 1][left];

            // traverse left to right in top row
            for (int j = left; j <= right; j++)
            {
                int temp = arr[top][j];
                arr[top][j] = prev;
                prev = temp;
            }

            // traverse top to bottom in right most column
            for (int i = top + 1; i <= bot; i++)
            {
                int temp = arr[i][right];
                arr[i][right] = prev;
                prev = temp;
            }

            // traverse right to left in bottom row
            for (int j = right - 1; j >= left; j--)
            {
                int temp = arr[bot][j];
                arr[bot][j] = prev;
                prev = temp;
            }

            // traverse bottom to top in left most column
            for (int i = bot - 1; i >= top + 1; i--)
            {
                int temp = arr[i][left];
                arr[i][left] = prev;
                prev = temp;
            }
        }
    }
};

int main()
{
    int t;
    cin >> t;
    cin.ignore(); // Ignore the tailing newline char
    cout << endl;

    while (t--)
    {
        int m, n;
        cin >> m >> n;
        // cin.ignore();

        vector<vector<int>> matrix(m, vector<int>(n));

        // Read the matrix
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                cin >> matrix[i][j];
            }
        }

        Solution ob;
        ob.rotateMatrix(matrix);

        // Print modified matrix
        for (const auto &row : matrix)
        {
            for (int val : row)
            {
                cout << val << " ";
            }
            cout << endl;
        }
        if (t > 0)
            cout << endl; // Print a blank line between test cases
    }
    return 0;
}