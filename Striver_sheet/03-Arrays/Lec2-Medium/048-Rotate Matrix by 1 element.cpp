#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <climits>
#include <sstream>
#include <algorithm>
#include <cmath>

using namespace std;

/*
Rotate Matrix by 1 element clockwise

https://www.naukri.com/code360/problems/981260?topList=striver-sde-sheet-problems&utm_source=striver&utm_medium=website&leftPanelTabValue=PROBLEM

Problem statement
Given a 2-dimensional matrix of size ‘N’ x ‘M’, rotate the elements of the matrix clockwise.

Note:
You have to rotate the image in-place

Examples:

Example1:
Input Matrix: [ [ 1, 2, 3 ]
                [ 4, 5, 6 ]
                [ 7, 8, 9 ] ]

Output Matrix: [ [ 4, 1, 2 ]
                 [ 7, 5, 3 ]
                 [ 8, 9, 6 ] ]

The output matrix is generated by rotating the elements of the input matrix in a clockwise direction. Note that every element is rotated only once.

Example2:
Sample Input 1 :
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
Sample Output 1 :
5 1 2 3
9 10 6 4
13 11 7 8
14 15 16 12

INPUT::::::
5

4 4
1  2  3  4
5  6  7  8
9  10 11 12
13 14 15 16

3 3
1 2 3
4 5 6
7 8 9

1 4
5 6 7 8

4 1
5
7
3
2

4 3
0 11 0
16 5 7
-4 17 6
11 16 18

OUTPUT::::::

5 1 2 3
9 10 6 4
13 11 7 8
14 15 16 12

4 1 2
7 5 3
8 9 6

5 6 7 8

5
7
3
2

16 0 11
-4 5 7
17 6 0
11 16 18

 */

class Solution
{
public:
    /*
  rotateMatrix: Rotate the matrix elements layer-by-layer by one step clockwise, in-place.

  Description:
    - This function performs a single-step clockwise rotation of every element in the matrix,
      working layer by layer (outer ring, then next inner ring, etc.).
    - Each layer's elements are shifted one position clockwise:
         top row  : left -> right
         right col: top+1 -> bottom
         bottom row: right-1 -> left
         left col : bottom-1 -> top+1
    - The rotation is done in-place using a temporary variable `prev` to carry the value
      that will be written into the next cell, avoiding extra per-cell allocations.

  Parameters:
    - mat : reference to a 2D vector representing the matrix to rotate.
            (Assumed rectangular with dimensions n x m.)
    - n   : number of rows in mat
    - m   : number of columns in mat

  Notes on correctness and boundaries:
    - We maintain four boundaries for the current layer: top, bot, left, right (inclusive).
    - The outer loop iterates while there is at least a 2x2 area to rotate (top < bot && left < right).
      This avoids degenerate 1-row or 1-column layers where a clockwise "one-step" rotation
      would be ambiguous or trivial.
    - `prev` holds the value that must be placed into the next cell; it is initialized to the
      value just inside the top-left corner (mat[top+1][left]) so that the first replacement
      at mat[top][left] correctly receives the predecessor value.
    - The `if (top == bot || left == right) break;` guard prevents backward traversals from
      re-visiting elements when the remaining layer becomes a single row or column after the
      first two traversals.

  Complexity:
    - Time:  O(n * m) — every element is moved a constant number of times (once per performed rotation).
    - Space: O(1) extra memory (in-place, only a few temporaries used).

  Behavior:
    - The function mutates `mat` in-place and returns no value.
    - For matrices with n < 2 or m < 2, the loop body will not execute and `mat` remains unchanged.
*/
    void rotateMatrix(vector<vector<int>> &mat)
    {
        int m = mat.size();    // number of rows
        int n = mat[0].size(); // number of columns

        /* Boundaries defining the current layer (inclusive indices) */
        int left = 0;
        int right = m - 1;
        int top = 0;
        int bot = n - 1;

        /*
          Process layer by layer. Each iteration rotates the current outer layer by one step
          clockwise. We require at least two rows and two columns in the current layer to
          perform the 4-side rotation (hence top < bot && left < right).
        */
        while (top < bot && left < right)
        {

            /*
              `prev` holds the element that will be written into the next cell visited.
              Initialize it with the element just inside the top-left corner of the current
              layer (row = top+1, col = left). This choice aligns the value flow so that
              the very first write (to mat[top][left]) receives the correct predecessor.
            */
            int prev = mat[top + 1][left];

            /* 1) Traverse top row: left -> right
               For each cell on the top row we:
                 - store current cell in temp
                 - write prev into current cell (effectively shifting prev forward)
                 - update prev with temp (for next write)
            */
            for (int col = left; col <= right; col++)
            {
                int temp = mat[top][col];
                mat[top][col] = prev;
                prev = temp;
            }

            /* 2) Traverse right column: top+1 -> bot
               Continue the same swap pattern down the rightmost column.
               Start at top+1 to avoid re-writing the corner already handled above.
            */
            for (int row = top + 1; row <= bot; row++)
            {
                int temp = mat[row][right];
                mat[row][right] = prev;
                prev = temp;
            }

            /*
              If after the top row and right column traversals the remaining submatrix
              reduced to a single row or column, further backward traversals would
              re-visit elements. Break out to avoid duplicates.
            */
            if (top == bot || left == right)
                break;

            /* 3) Traverse bottom row: right-1 -> left
               Move left along the bottom row, continuing to place prev into each cell.
               We start at right-1 to avoid re-writing the bottom-right corner.
            */
            for (int col = right - 1; col >= left; col--)
            {
                int temp = mat[bot][col];
                mat[bot][col] = prev;
                prev = temp;
            }

            /* 4) Traverse left column: bot-1 -> top+1 (upward)
               Move up the leftmost column, again writing prev and updating it from temp.
               Use row > top to avoid touching the top-left corner, already updated in step 1.
            */
            for (int row = bot - 1; row > top; row--)
            {
                int temp = mat[row][left];
                mat[row][left] = prev;
                prev = temp;
            }

            /* Move inward to the next layer */
            top++;
            bot--;
            left++;
            right--;
        }

        /* End: mat is rotated in-place by one clockwise step for each processed layer */
    }

    /**
     * Rotate Matrix Elements (Layer-by-Layer Rotation)
     * ------------------------------------------------
     * Problem:
     *   - Rotate all elements of a matrix (not necessarily square) in a circular fashion.
     *   - This rotates each "ring" (outer layer, then inner layer, etc.) by one position.
     *
     * Key Points:
     *   - For square matrices (m == n), standard rotation rules apply.
     *   - For rectangular matrices (m != n), only min(m, n) layers exist,
     *     so we take N = min(m, n).
     *   - Only floor(N/2) full layers can be rotated because if N is odd,
     *     the central row/column would otherwise leave a single element, which doesn’t rotate.
     *
     * Approach:
     *   - Process the matrix in layers (like peeling an onion).
     *   - For each layer, traverse in 4 steps:
     *       1. Top row (left → right)
     *       2. Rightmost column (top → bottom)
     *       3. Bottom row (right → left)
     *       4. Leftmost column (bottom → top)
     *   - Keep track of the "previous" element and swap as we move along,
     *     effectively rotating elements by one position.
     *
     * Time Complexity:  O(m * n)  [every element visited once]
     * Space Complexity: O(1)      [in-place]
     */
    
    // void rotateMatrix(vector<vector<int>> &arr)
    // {
    //     int m = arr.size();    // number of rows
    //     int n = arr[0].size(); // number of columns

    //     // Layers exist up to min(m, n) / 2
    //     int N = min(m, n);
    //     int noOfInnerMatrices = N / 2; // floor handles odd dimension (avoid single leftover element)

    //     // Process each layer
    //     for (int k = 0; k < noOfInnerMatrices; k++)
    //     {
    //         int left = k;          // left boundary
    //         int right = m - 1 - k; // right boundary (row index)
    //         int top = k;           // top boundary
    //         int bot = n - 1 - k;   // bottom boundary (column index)

    //         // Save the first element (to reinsert later)
    //         int prev = arr[top + 1][left];

    //         // 1. Traverse top row (left → right)
    //         for (int j = left; j <= right; j++)
    //         {
    //             int temp = arr[top][j];
    //             arr[top][j] = prev;
    //             prev = temp;
    //         }

    //         // 2. Traverse right column (top → bottom)
    //         for (int i = top + 1; i <= bot; i++)
    //         {
    //             int temp = arr[i][right];
    //             arr[i][right] = prev;
    //             prev = temp;
    //         }

    //         // 3. Traverse bottom row (right → left)
    //         for (int j = right - 1; j >= left; j--)
    //         {
    //             int temp = arr[bot][j];
    //             arr[bot][j] = prev;
    //             prev = temp;
    //         }

    //         // 4. Traverse left column (bottom → top)
    //         for (int i = bot - 1; i >= top + 1; i--)
    //         {
    //             int temp = arr[i][left];
    //             arr[i][left] = prev;
    //             prev = temp;
    //         }
    //     }
    // }
};

int main()
{
    int t;
    cin >> t;
    cin.ignore(); // Ignore the tailing newline char
    cout << endl;

    while (t--)
    {
        int m, n;
        cin >> m >> n;
        // cin.ignore();

        vector<vector<int>> matrix(m, vector<int>(n));

        // Read the matrix
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                cin >> matrix[i][j];
            }
        }

        Solution ob;
        ob.rotateMatrix(matrix);

        // Print modified matrix
        for (const auto &row : matrix)
        {
            for (int val : row)
            {
                cout << val << " ";
            }
            cout << endl;
        }
        if (t > 0)
            cout << endl; // Print a blank line between test cases
    }
    return 0;
}