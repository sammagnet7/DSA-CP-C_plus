#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <climits>
#include <sstream>
#include <algorithm>

using namespace std;

/*
Rotate Image by 90 degree clockwise/ anti-clockwise

https://takeuforward.org/data-structure/rotate-image-by-90-degree/
https://takeuforward.org/data-structure/rotate-matrix-anti-clockwise-by-90-degree/
https://leetcode.com/problems/rotate-image/description/
https://www.naukri.com/code360/problems/981260?topList=striver-sde-sheet-problems&utm_source=striver&utm_medium=website

Problem Statement: You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).

Note:
-231 <= matrix[i][j] <= 231 - 1
You have to rotate the image in-place

Examples:

Input Matrix:
[
 [ 1, 2, 3 ]
 [ 4, 5, 6 ]
 [ 7, 8, 9 ]
]

Output Matrix:
[
 [ 7, 4, 1 ]
 [ 8, 5, 2 ]
 [ 9, 6, 3 ]
]

The output matrix is generated by rotating the elements of the input matrix in a clockwise direction.

INPUT::::::
2

3 3
1 2 3
4 5 6
7 8 9

4 4
5 1 9 11
2 4 8 10
13 3 6 7
5 14 12 16

OUTPUT::::::

7 4 1
8 5 2
9 6 3

5 13 2 5
14 3 4 1
12 6 8 9
16 7 10 11

 */

class Solution
{
public:
    /**
     * Rotate Image (LeetCode 48) — Using Extra Matrix
     * -----------------------------------------------
     * Problem:
     *   - Given an n x n 2D matrix, rotate it by 90 degrees clockwise in-place.
     *   - Here we solve it with an auxiliary matrix for clarity.
     *
     * Approach:
     *   - For each cell (i, j) in the original matrix:
     *       rotated[j][n - i - 1] = matrix[i][j]
     *     This maps row -> column and column -> reversed row,
     *     which achieves a 90° clockwise rotation.
     *   - After constructing `rotated`, copy it back into the original matrix.
     *
     * Time Complexity:  O(n^2)  (two passes over all cells)
     * Space Complexity: O(n^2)  (extra matrix of same size)
     *
     * Notes:
     *   - This is not the in-place optimal solution, but it is simpler to implement
     *     and good for understanding the rotation mapping.
     */
    void rotate(vector<vector<int>> &matrix)
    {
        int n = matrix.size();

        // Step 1: Create an empty matrix to store rotated result
        vector<vector<int>> rotated(n, vector<int>(n, 0));

        // Step 2: Fill rotated matrix using rotation rule
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                // Place element at (i,j) into its rotated position
                rotated[j][n - i - 1] = matrix[i][j];
            }
        }

        // Step 3: Copy rotated matrix back into original
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                matrix[i][j] = rotated[i][j];
            }
        }
    }

    /**
     * Rotate Image (LeetCode 48) — Optimal In-place Solution
     * ------------------------------------------------------
     * Problem:
     *   - Given an n x n 2D matrix, rotate it 90 degrees clockwise in-place.
     *
     * Observation:
     *   - A 90° clockwise rotation can be achieved in two steps:
     *       1. Transpose the matrix
     *           → Convert rows into columns.
     *       2. Reverse every row
     *           → Align columns to match clockwise rotation.
     *
     * For example:
     *   Input:           After Transpose:       After Row Reversal:
     *   1 2 3            1 4 7                  7 4 1
     *   4 5 6     -->    2 5 8     -->          8 5 2
     *   7 8 9            3 6 9                  9 6 3
     *
     * Anti-clockwise Rotation:
     *   - Transpose the matrix.
     *   - Then reverse each COLUMN instead of each row.
     *
     * Time Complexity:  O(2 * n^2) = O(n^2)
     * Space Complexity: O(1)  (in-place)
     */
    void rotate(vector<vector<int>> &matrix)
    {
        int n = matrix.size();

        // Step 1: Transpose the matrix (swap matrix[i][j] with matrix[j][i])
        for (int i = 0; i < n; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                swap(matrix[i][j], matrix[j][i]);
            }
        }

        // Step 2: Reverse each row (to complete clockwise rotation)
        for (int i = 0; i < n; i++)
        {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};

int main()
{
    int t;
    cin >> t;
    cin.ignore(); // Ignore the tailing newline char
    cout << endl;

    while (t--)
    {
        int m, n;
        cin >> m >> n;
        // cin.ignore();

        vector<vector<int>> matrix(m, vector<int>(n));

        // Read the matrix
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                cin >> matrix[i][j];
            }
        }

        Solution ob;
        ob.rotate(matrix);

        // Print modified matrix
        for (const auto &row : matrix)
        {
            for (int val : row)
            {
                cout << val << " ";
            }
            cout << endl;
        }
        if (t > 0)
            cout << endl; // Print a blank line between test cases
    }
    return 0;
}