#include <iostream>
#include <vector>
#include <set>
#include <unordered_map>
#include <queue>
#include <climits>
#include <sstream>
#include <numeric>
#include <algorithm>
#include <cmath>
#include <map>
#include <unordered_set>
#include <stack>
#include <string.h>
#include <list>

using namespace std;

/*

1. Title: Count and say

Links:
https://takeuforward.org/plus/dsa/problems/count-and-say?tab=editorial
https://leetcode.com/problems/count-and-say/


Problem statement:
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:

countAndSay(1) = "1"
countAndSay(n) is the run-length encoding of countAndSay(n - 1).
Run-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "3322251" we replace "33" with "23", replace "222" with "32", replace "5" with "15" and replace "1" with "11". Thus the compressed string becomes "23321511".

Given a positive integer n, return the nth element of the count-and-say sequence.

Example:
    Example 1:
    Input: n = 4
    Output: "1211"
    Explanation:
    countAndSay(1) = "1"
    countAndSay(2) = RLE of "1" = "11"
    countAndSay(3) = RLE of "11" = "21"
    countAndSay(4) = RLE of "21" = "1211"

    Example 2:
    Input: n = 1
    Output: "1"
    Explanation:
    This is the base case.


Constraints:
1 <= n <= 30

Follow up: Could you solve it iteratively?


INPUT::::::


OUTPUT::::::


----------------------------------------------------------------------------------------------------

2. Title:


Links:


Problem statement:



INPUT::::::


OUTPUT::::::


----------------------------------------------------------------------------------------------------

*/

//-------------------------------------------------------------------------------
// 1. Title: Count and say
//-------------------------------------------------------------------------------
//

class Solution
{
public:
    // ------------------------------------------------------------------------
    // Approach 1 - Recursive (Top-down RLE)
    //
    // Intuition:
    // The "count-and-say" sequence is generated by reading off the previous
    // term's run-length encoding (RLE). This implementation performs RLE on the
    // current string and then calls itself recursively to produce the next term.
    //
    // recCountAndSay(n, RLE):
    //  - If n == 0, we have produced enough terms → return current RLE string.
    //  - Otherwise, compute the run-length encoding (RLE) of the current string
    //    into `tmp` (e.g., "111221" -> "312211"), then recurse with n-1 and tmp.
    //
    // countAndSay(n):
    //  - Start from base string "1" (the 1st term) and call recursion n-1 times.
    //
    // Complexity:
    //  - Let L_k be the length of the k-th term. The sequence length grows
    //    roughly multiplicatively (≈ 1.3^k average). Generating each next term
    //    scans the previous string once.
    //  - Time: O(sum of lengths of terms up to n) (practically exponential in n,
    //    but n is small in typical constraints e.g., n ≤ 30).
    //  - Space: O(L_n) for the recursion stack + temporary string (depth n).
    // ------------------------------------------------------------------------
    string recCountAndSay(int n, string &RLE)
    {
        // Base case: if no more terms to generate, return current string
        if (n == 0)
        {
            return RLE;
        }

        // Build next term via run-length encoding of RLE
        string tmp = "";
        char ch = RLE[0];
        int count = 1;

        // Start from index 1 and accumulate runs
        for (int i = 1; i < RLE.size(); i++)
        {
            if (ch == RLE[i])
            {
                // same char -> extend current run
                count++;
            }
            else
            {
                // run ended -> append "<count><char>" to tmp
                tmp.append(to_string(count));
                tmp.push_back(ch);

                // start a new run
                ch = RLE[i];
                count = 1;
            }
        }

        // append the final run if any
        if (count >= 1)
        {
            tmp.append(to_string(count));
            tmp.push_back(ch);
        }

        // Recurse to generate remaining (n-1) terms
        return recCountAndSay(n - 1, tmp);
    }

    // Public entry: build sequence starting from "1" and perform n-1 recursions
    string countAndSay(int n)
    {
        string ini = "1";
        return recCountAndSay(n - 1, ini);
    }
};

class Solution
{
public:
    // ------------------------------------------------------------------------
    // Approach 2 - Iterative (Bottom-up RLE)
    //
    // Intuition:
    // Build the sequence iteratively from the first term. For each iteration,
    // run-length-encode the current term to produce the next term. Repeat
    // (n-1) times starting from "1".
    //
    // countAndSay(n):
    //  - Initialize RLE = "1".
    //  - For i from 1 to n-1: produce tmp = RLE's RLE and assign RLE = tmp.
    //  - Return RLE after n-1 transformations.
    //
    // Complexity:
    //  - Same growth characteristics as the recursive method.
    //  - Time: O(sum of lengths of terms up to n).
    //  - Space: O(L_n) for temporary string used each iteration.
    // ------------------------------------------------------------------------
    string countAndSay(int n)
    {

        string RLE = "1"; // 1st term

        // Generate terms 2..n
        for (int i = 1; i < n; i++)
        {

            string tmp = "";
            char ch = RLE[0];
            int count = 1;

            // Build next term by scanning current RLE once
            for (int i = 1; i < RLE.size(); i++)
            {

                if (ch == RLE[i])
                {
                    // same run -> increment
                    count++;
                }
                else
                {
                    // run ended -> append "<count><char>"
                    tmp.append(to_string(count));
                    tmp.push_back(ch);

                    // reset for next run
                    ch = RLE[i];
                    count = 1;
                }
            }

            // append the final run
            if (count >= 1)
            {
                tmp.append(to_string(count));
                tmp.push_back(ch);
            }

            // move to the next term
            RLE = tmp;
        }

        return RLE;
    }
};

//-------------------------------------------------------------------------------
// 2. Title:
//-------------------------------------------------------------------------------
//

int main()
{
    return 0;
}